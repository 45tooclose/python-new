
Bug Weekly #4: PermissionsFrom the file system to web services, permissions allow an owner of a resource to determine who has access to what within their domain. Today we’re going to talk about the former which is file system access control. We’ve been filing a number of bugs recently that are related to permissions during our pro-bono campaign to help shore up issues across multiple blockchain projects.But what exactly is the problem?Many code bases work with files, it’s a common thing to do. Opening them to read configuration, writing out logs, deleting stuff that’s no longer needed on cleanup, etc. The issue is when files are created with excess permissions that allow anyone else in shared environments or have accessible filesystems over the web or otherwise to assume complete control over the file or folder with overly broad permissions set.os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)The above example creates or opens to append data to the specified file in path with read-write privileges to not only the owner and users in the same group, but to everyone on the system. There are very few cases where you’d want to have anyone be able to read, write, execute, delete or modify your files. Defense in depth practices say that you should scope permissions down using the least-privilege possible concept. Whoever explicitly needs to touch the file can, but everyone else cannot. In this case, only the owner (application) should be able to read and write to the path passed, or at most folks in the same group should be able to maybe read it. Everyone else should not have access to the file with few exceptions.os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0600)What’s the impact?It depends on what the code is doing. If it’s simply creating a log file to write to, anyone can delete or modify to fake those logs. Deleting a file that the application expects to be there, depending on how the code handles that scenario, could cause it to crash. If the file is a plugin that the application will consume to execute commands or additional code from, the impact could be arbitrary code execution as anyone could replace the plugin with their own malicious one and make the application do as they please. One can cryptographically sign the plugins and ensure that only signed ones will be loaded, but that’s another rabbit hole that requires more expensive infrastructure to support it properly than many projects could afford to do (but many larger companies such as Google and Microsoft standardize on)./BA Team