
How to develop Ethereum DApps with Solidity and ganache-cliAs I found it difficult to find an easy start into the development of DApps, I wanted to provide a short & easy tutorial. Please let me know if something doesn’t work. I will keep this article up to date.This article will have a second part describing how to use web3 and React to build a client for the application.DApps are decentralized digital applications or programs. They run e. g. on a blockchain instead of a single computer.What are the advantages of DApps?You won’t need to integrate a service like PayPal into your application, because all users can send/receive Ether as a common payment. Also storing data in the blockchain is expensive, that’s why it’s very important to determine which data should be stored in the blockchain. But it’s possible to use it as database. Actually you won’t need registration and user management, because every user has a key that is bound to the user session and metadata. One of the best parts of the blockchain is, that you can trust your code and it’s visible.„Convinced? Let’s start with the development!“If you have read this, you will be able to develop Ethereum DApps.This picture helped me to understand the basic concepts for the development:key connection between the Ethereum network and your dappWe will start developing an application with a test system. When everything is working fine we can deploy it on the real Ethereum platform.RequirementsNode.js (>= v6.11.5)Basics of React/JavaScriptMetaMask for Google Chrome„Everything is there? Now it really starts.“1. You should start developing your DApps on a local Ethereum testrpc.I recommend using the Ganache CLI by Truffle for fast, easy and safe development of Ethereum applications. It makes it easy to simulate full client behavior.Here is how to install the ganache-cli on your machine:> npm install -g ganache-cliAnd run it with the following command:> ganache-cliganache provides you 10 accounts and 10 private keys by default at startupNow you have a local ethereum testrpc. It typically runs on http://localhost:8545.2. It doesn’t work without MetaMask/Mist.I’m using the MetaMask Ethereum Plugin for Google Chrome. You can install it here.An alternative you could use is Mist. If you want maximum security I recommend using Mist, but I will go on with MetaMask.MetaMask is a bridge to use DApps within your Browser.After installing the plugin, you first have to accept the private notice and the terms of use. Next you can enter a strong password. You will need this password in the future, so please don’t loose it.On the next site you can see your Seed Phrase. This one is VERY important, so also make sure you don’t lose it.To use MetaMask during development, select localhost 8545 as your network.3. Smart Contracts are written with Solidity.The best way to try out Solidity is Remix.„To be honest, this sentence would not have said anything to me two days ago.“Solidity is a JavaScript-like programming language used to develop smart contracts for the Ethereum Blockchain platform.Remix is an IDE (available online) that is used for programming Smart Contracts with Solidity.Here is an example for a smart contract I have implemented in Solidity with Remix. It will also explain it in detail, but I first I want to show you with this example how to create the smart contract.This will now be explained in detail. But first I want to show you how to create this smart contract. As you have started your ganache-cli you have to do the following settings within Remix:Check whether the code is compilable.Create it on your locale testrpc.Solidity source code files are usually annotated with a so-called version pragma. It means that this source file will not compile with a compiler earlier than version 0.4.0.pragma solidity ^0.4.0;In the next line, you can see the contract Owned. Similar to JavaScript classes it’s then opened up.contract Owned {  ...}Then we define our variables and specify the types of the variables.address owner;The following types are availyble in Solidity:bool — returns true or falseint/uint — both represent numbers, int can also have negative numbers as valuesbytes — dynamically-sized byte arraybytes1 (through 32) — fixed-size byte arraystring — dynamically signed stringaddress — 20 byte value, is meant to store an Ethereum addressstruct — define new typesmapping — hash table with key and value typesThe following source code shows a public constructor for Owned. msg.sender gives the direct sender of the message. constructor() public {     owner = msg.sender; }To make a contract inherit from a base contract, you can use modifiers. This modifier can be used in functions and makes sure, that the required condition is true. In this example it’s used in the setReader -function. So just the contract owner has the possibility to add a reader.modifier onlyOwner {    require(msg.sender == owner);    _;}Here an event is created. To use an event you have to call it. In this case the readerInfo -event is emitted in the setReader -function. This meand that the event is fired when the new reader is successfully added and can be accessed now.event readerInfo(    bytes16 name,    uint age);The following two functions are setReader(..) and getReader(...) . The setReader -function accepts 3 parameters. Then a new Reader is created and it’s age and name is set. In the next line the reader is pushed into the readerAccts -Array. In the last line the readerInfo -Event is emitted. As I already desribed this functions has the modifier onlyOwner which ensured that only the owner can use this function.function setReader(address _address, uint _age, bytes16 _name) onlyOwner public {    Reader storage reader = readers[_address];            reader.age = _age;    reader.name = _name;            readerAccts.push(_address) -1;    emit readerInfo(_name, _age);}The setReader -functions accepts 1 parameter: the address of a reader and return the age and the name of the reader.function getReader(address _address) view public returns (uint, bytes16) {    return (readers[_address].age, readers[_address].name);}So now you know how to define a smart contract. Maybe this example will help you with your idea.The next step is to create a react app and to access the smart contract via a web3 object. I will explain how it works in another article.I hope you liked my tutorial and I would be very happy about your comment and some clapping hands :-).