
Dual Authoring — a solução Loopring para Front-RunningLoopring é um protocolo usado para criar trocas descentralizadas. Neste post, falaremos brevemente sobre a questão do front-running em intercâmbio descentralizados, e ver como foi aplicado a solução de autorização dupla (Dual Authoring) de Daniel.Uma versão anterior foi arquivada em IPFS: QmX48qyrSUdcvrJ2rFVrmvPxk6dkdoYKTGVBMRHC3ahzMh (PDF).Daniel Wang, nosso fundador, pesquisou e desenvolveu uma solução aprimorada para prevenção de de front-running chamada, Dual Authoring. Entramos com pedidos de patentes e codificamos a solução em nossos contratos inteligentes. Este recurso será implantado como parte da nossa versão 1.2 do protocolo. Acreditamos que o Dual Authoring nos trará uma vantagem competitiva muito boa.Front-Running em Exchanges Descentralizadas“Front running é uma prática ilegal de obtenção de informações antecipadas sobre a realização de operação nos mercados de bolsa ou de balcão e que influenciarão a formação dos preços de determinados produtos de investimento.” [wikipedia]Em exchanges decentralizadas, front-running é quando alguém tenta minerar transações, antes de minerar outras transações que já estão prontas no grupo de transações pendentes (mempool). Isso pode ser realizado ao especificar uma taxa de transação mais alta (preço do gas ), e se o front-runner for por acaso um minerador, ele pode colocar ordens para transações pendentes e se beneficiar.O principal esquema de front-running no Loopring (e qualquer protocolo para a correspondência de ordens) são furto de ordens e furto de rings. Furto de ordens é quando um front-runner furta uma ou mais ordens de uma transação de liquidação pendente de um ring; e furto de rings é quando um front-runner furta o ring inteiro da transação pendente.Antes de continuar, vale mencionar que a ferramenta de correspondência padrão do Loopring não garante Ordem de Chegada (em vez disso, ela usa o modelo de balcão ou OTC), o que significa que os carimbos de tempo das ordens são totalmente ignorados. Isso também implica que fazer o front-running de uma transação não tem impacto sobre o preço real desta transação — o Loopring apenas suporta ordens de preço limitado.Anatomia de Ordens e Rings no Loopring 1.0 e 1.1Ordens e AssinaturasOrdens no Loopring são criadas por carteiras e ferramentas que podem ajudar a gerenciar as chaves privadas de um usuário. As ordens são trechos de JSON e são transferidas a relés na forma de pacotes de dados JSON via APIs. Segue um exemplo de uma ordem na versão 1.0 do Loopring:Uma Ordem no Loopring 1.0O campoownerrepresenta o owner_address da ordem, onde os tokens serão transferidos assim que a ordem for preenchida. A ordem (incluindo o owner_address) deve ser assinada com a chave privada do owner_address. A ordem será válida apenas se a order_signature (representado pelo r, v, e s) for válida.Conforme ilustrado pelo diagrama abaixo, a order_signature é de fato assinada contra o hash da ordem (ou order_hash), que é a saída da função keccak256 de todos os outros campos exceto r, v, e s.Uma Ordem no Loopring 1.0 e 1.1É fácil computar oorder_hash que então é usado para verificar se o endereço de assinatura é de fato o owner_address da ordem ou não. Os relés irão verificar a assinatura de cada ordem que recebem; o contrato inteligente do Protocolo Loopring também verifica as assinaturas de ordens quando 1) as ordens são enviadas como parte de um ring e 2) ordens são enviadas para cancelamento.Rings e AssinaturasO Rings não assumem uma forma JSON, em vez disso são representados por todos os parâmetros da função submitRing fornecida pelo Protocolo Loopring. Mas se visualizarmos um ring, ele terá uma aparência semelhante à da figura abaixo — ele protege todos os dados de suas ordens (um ring pode ter de 2 a 10 ordens). Os mineradores do ring também irá preencher seu endereço (o miner_address) e outros parâmetros de mineração (ou parâmetros de ring) no ring para que a função submitRing se comporte de forma diferente com base nos parâmetros de entrada.Os mineradores precisam assinar o hash de um ring ( ring_hash), junto com todos os parâmetros de mineração e com a chave privada do miner_address. Oring_hash pode ser calculado como o resultado da operação XOR de todos os order_hash ou usando outras funções hash.O Processo de assinatura de ring no Loopring (1.0)Observe que o protocolo não requer msg.sender para assinar algo. Em outras palavras, um ring — como a carga da transação submitRing pode ser assinado por um endereço de mineração e a transação de blockchain em si pode ser assinada (e transmitida) por um endereço transacional diferente. O desacoplamento de um endereço de mineração e endereço transacional fornecem uma flexibilidade maior e uma vantagem adicional de segurança.O diagrama abaixo ilustra a carga (ou os parâmetros) de uma transação submitRing por um ring de 3 ordens.Carga da Função submitRing (3 Ordens)Por que os mineradores precisam assinar os rings? Precisamos garantir que todas as estatísticas de transações sejam calculadas/atualizadas para os mineradores corretos. Essas estatísticas podem ser usadas por membros na blockchain do consórcio de compartilhamento de liquidez para calcular a produção de ordens e consumo de cada membro, e consolidar os pagamentos entre os membros do consórcio.Front-Running e Furto de RingsConforme descrito na seção acima, quando uma transação submitRing não está confirmada no grupo de transações pendentes, qualquer pessoa pode visualizar facilmente essa transação e substituir o miner_address por seu próprio endereço (o filcher_address) , depois ele pode reassinar a carga com o filcher_address para substituir a assinatura do ring. O furtador pode definir um preço de gas mais alto e enviar uma nova transação na expectativa de que mineradores de blocos escolham sua nova transação para o próximo bloco em vez da transação original submitRing.Carga Furtada (3 Ordens)A Solução no 1.0 e 1.1Na v1.0 e 1.1, nós permitimos que mineradores de rings possam acionar a função batchSubmitRinghash ou submitRinghash para reservar hashes de rings antes de enviar os rings de fato. Quando um ring é enviado, o protocolo verifica se o hash do ring já foi enviado/reservado por outros mineradores, se for positivo, o protocolo irá rejeitar o anel e a transação submitRing irá falhar.Há mais desvantagens nesta solução: ela requer mais transações, portanto o custo do gas dos mineiros é maior; e requer pelo menos o dobro do tempo (tempo de bloco) para liquidar um ring. Isso inaceitável.Dual Authoring — Nossa Nova SoluçãoNossa nova solução envolve o mecanismo de configurar dois níveis de autorização para ordens: uma para liquidação e outro para mineração. Nós o chamamos de Dual Authoring.Como FuncionaA Dual Authoring funciona da seguinte forma:1. Para cada pedido, a carteira gerará um par de chave pública / chave privada, o par de chaves será inserido no snippet JSON do pedido. (Uma alternativa é usar o endereço derivado da chave pública em vez da própria chave pública para reduzir o tamanho em bytes. Usamos auth_addres para representar tal endereço, e auth_private_key para representar a chave privada correspondente do auth_addres).2. Todos os campos na ordem exceto auth_private_key são assinados usando a chave privada do owner_address (não a auth_private_key) representada na imagem abaixo.A Order in Loopring 1.23. A carteira irá enviar o pedido, junto com a auth_private_key os mineradores (relés) a serem correspondidos. Os mineiros verificarão se auth_private_key e auth_address são correspondidos corretamente e se a assinatura do pedido é válida com relação ao endereço do owner_address.4. Quando um ring é identificado, o minerador irá usar a auth_private_key de cada ordem para assinar o ring_hash, miner_address, e todos os mining_parameters. No exemplo abaixo, o anel contém três ordens, portanto, haverá três assinaturas das três chaves auth_private_key's. Nós chamamos essas assinaturas de auth_signature. Os mineiros também precisarão assinar o ring_hash junto com todos os parâmetros de extração usando a chave privada dominer_address ,tanto no protocolo v1.0 e 1.1.Processo de Assinatura do anel no Loopring (1.2) usando Dual Authoring5. O minerador chama a função submitRing com todos os parâmetros no v1.0 e 1.1, bem como as 3 auth_signature's. Observe que as auth_private_keys NÃO são parte da transação on-chain a portanto permanecem desconhecidas, exceto para o relé, conforme representado na ilustração abaixo.Um Anel Loopring (1.2) (apenas visto em TXs on-chain)6. O Protocolo Loopring irá verificar agora cada auth_signature contra o auth_address correspondente de cada pedido, e rejeitar o ring se qualquer auth_signature for inválida.Por Que FuncionaAgora um ring não pode ser furtado por ninguém, a menos que ele tenha todas as auth_private_key's de todas as ordens inclusas. Isso acontece porque:A assinatura da ordem (pela chave privada do ower_address) garante que a ordem não possa ser modificada, incluindo o auth_address.A assinatura dos mineradores (pela chave privada do miner_address) garante que ninguém possa usar sua identidade para minerar um anel.As auth_signature's garantem que o ring inteiro não possa ser modificado, incluindo o miner_address. E como os furtadores de rings não têm acesso às auth_private_key's, eles não podem gerar novamente um novo conjunto de auth_signature's, portanto são incapazes de gerar uma transação de furto.Variantes da Dual AuthoringParcial da Dual AuthoringDual Authoring requer assinaturas de todas as auth_private_key's em um ring. Uma variante da Dual Authoring é solicitar uma ou apenas algumas auth_signature's. O esquema de Dual Authoring parcial também garante que um ring não pode ser roubado em sua totalidade, mas ainda está sujeito a ordens de furto (ordem-flich), e o flicher pode usar as ordens roubadas em outro Dual Authoring parcial, ativando pagamentos de transações de liquidações em que auth_private_key's das ordens roubadas não serão necessárias.Compartilhamento de Chave da Dual AuthoringUm relé pode gerar um par auth_address /auth_private_key e exigir que todas as carteiras conectadas a ele utilizem o mesmo auth_address compartilhado para todas as ordens (como as carteiras não possuem a auth_private_key, este é uma campo faltante nos pacotes de dados de pedidos da JSON API). O esquema de Dual Authoring de Compartilhamento de Chaves permite apenas ao relé minerar as ordens para as quais ele gera o par auth_address/auth_private_key . Portanto, as carteiras não têm a opção de compartilhar ordens com os outros relésImplantaçãoA Dual Authoring foi implantada em nosso repositório protocolo, o pull request está atualmente sob revisão, e os testes serão atualizados em breve.ResumoA solução de Dual Authoring do Daniel Wang impede roubo de anel e roubo de pedidos, embora ainda garanta que a liquidação de anéis possa ser realizada em uma única transação. Além disso, a, Dual Authoring permite que os relés compartilhem ordens de duas formas: compartilhamento sem correspondência e compartilhamento com correspondência.Se você tiver perguntas ou sugestões com relação à Dual Authoring, envie um e-mail diretamente para o Daniel Wang.Atualização: Decidimos lançar esse recurso com parte da v1.1.