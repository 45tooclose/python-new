
Even Digital Cats Have FleasLast month I created some tools for CryptoKitties that allow people to monitor kitty sales and sire auctions in real-time as they hit the blockchain. After publishing the tools, I noticed that the page monitoring for successful sires was incorrectly attributing all sires to the core CryptoKitties contract address 0x06012c8cf97bead5deae237070f9587f8e7a266d. Of course, I thought I made an error and proceeded to go through my code in an attempt to find the bug. However, upon further investigation, I realized that my code was not the culprit (in this rare case). My code simply reports events generated from the the CryptoKitties siring contract, and the events coming from the contract always attributed the winner of a siring auction to the core CryptoKitties contract.Below is a snippet of the _bid() function from the ClockAuctionBase contract that SiringClockAuction is inherited from.As you can see, an AuctionSuccessful event is emitted with the token ID, price, and (supposedly) the bidder’s address. _bid() function is defined in the base ClockAuctionBase and shared by both the sales contract and siring contract. This means the event is generated the same way for both a sales auction and a siring auction. However, my tool for monitoring sales auctions was correctly reporting winner addresses, but the siring tool was not…curious.As it turns out, the _bid() function gets call differently for sales auctions and siring auctions. Let’s step back for a second and review how the CryptoKitties contracts are setup. There are 3 main public contracts: KittyCore, SaleClockAuction, and SiringClockAuction (a 4th obfuscate contract handles gene science). Anyone can view these contracts on etherscan and call into the public functions. As its name implies, KittyCore handles core game features including token management and breeding. The two auction contracts handle marketplace interactions where you can buy, sell, and sire kitties.Since both auction contracts share the same code for bidding actions, you would think that the events generated by them would contain the same kind of data: kitty ID, price and bidder address. However, an inconsistency in how the contracts are called is what led to the above error. When bidding to buy a kitty, the SaleClockAuction is called directly via the bid() function, but when bidding on a siring auction, the call to SiringClockAuction.bid() is proxied through KittyCore.bidOnSiringAuction(). This means that when SiringClockAuction.bid() is called, msg.sender is the address of KittyCore instead of the actual bidder’s address. There is even a line in SiringClockAuction.bid() that prevents calls from any other address.OK! So I figured out why I was getting incorrect data from the contract…but if the event is being created with incorrect data, could that bad value be used elsewhere in the contract? Look at the line of code just before the call to generate the event.Whoa. We’ve already established that msg.sender is incorrectly used to generate the AuctionSuccessful event, but just one line before ETH is transferred to that wrong address! Now, generating a log with bad data is a nuisance, but sending ETH to the wrong address has a much bigger impact.At this point, I checked the “internal transactions” for the siring contract and indeed verified that small amounts of ETH were being sent to KittyCore’s address. The CryptoKitties auction contracts were designed to send any overpayments back to the bidder, but in this case the excess was sent to KittyCore’s address. Fortunately, in most cases these amounts are tiny fractions of an ETH. There are, of course, cases where the amount of ETH “lost” could be more significant. If you call the siring contract manually and send a large overpayment, that overpayment would not be sent back to you (I’ve personally sent a 10x overpayment to the sales auction contract and was luckily reimbursed). Another case would be if you bid on a price-declining siring auction and specify a very low gas price that causes your transaction to take a long time to confirm. Assuming no one else outbids you, you should be refunded the difference between the price of the auction at the time of bid and the price of the auction at the time of transaction confirmation.Having verified the bug, I reported the issue to CryptoKitties and they have since <acknowledged the issue and outlined a plan> to compensate past and future losses. As a reward for reporting this issue to them, CryptoKitties was nice enough to send me a very nice Gen 0 kitty.three ninety-six